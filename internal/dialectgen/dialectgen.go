package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"os"
	"path/filepath"
	"runtime"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/rrgmc/litsql/internal/dialectgen/genutil"
	"golang.org/x/exp/maps"
	"golang.org/x/tools/go/packages"
)

var (
	dialect = flag.String("dialect", "", "dialect folder name (ex: psql, mysql, sqlite")
	dryRun  = flag.Bool("dry-run", false, "dry run")
)

func main() {
	flag.Parse()
	if len(*dialect) == 0 {
		fmt.Println("dialect is required")
		os.Exit(2)
	}

	err := runDialect()
	if err != nil {
		panic(err)
	}
}

func runDialect() error {
	config, err := LoadConfig()
	if err != nil {
		return err
	}

	chainDir := filepath.Clean(filepath.Join(getCurrentDir(), "..", "..", "sq", "chain"))
	chainPkg, err := genutil.PkgInfoFromPath(
		chainDir, packages.NeedName|packages.NeedTypes,
	)
	if err != nil {
		return fmt.Errorf("couldn't load chain package: %s", err)
	}

	for _, sdir := range []string{"sm", "im", "um", "dm"} {
		err := runPkg(config, sdir, chainPkg)
		if err != nil {
			return err
		}
	}
	return nil
}

func runPkg(config Config, sdir string, chainPkg *packages.Package) error {
	var sname string
	switch sdir {
	case "sm":
		sname = "Select"
	case "im":
		sname = "Insert"
	case "um":
		sname = "Update"
	case "dm":
		sname = "Delete"
	default:
		return fmt.Errorf("unknown sdir: %s", sdir)
	}

	sdialect := *dialect

	currentDir := getCurrentDir()
	ismDir := filepath.Clean(filepath.Join(currentDir, "..", "i"+sdir))
	dialectDir := filepath.Clean(filepath.Join(currentDir, "..", "..", "dialect"))
	curDialectDir := filepath.Join(dialectDir, sdialect)
	smDir := filepath.Join(curDialectDir, sdir)

	rootpkg := "github.com/rrgmc/litsql"
	ispkg := "github.com/rrgmc/litsql/internal/i" + sdir
	isqpkg := "github.com/rrgmc/litsql/internal/isq"
	imodpkg := "github.com/rrgmc/litsql/internal/imod"
	sqpkg := "github.com/rrgmc/litsql/sq"
	sqchainpkg := sqpkg + "/chain"
	sqmodpkg := sqpkg + "/mod"
	sdialectpkg := fmt.Sprintf("github.com/rrgmc/litsql/dialect/%s", sdialect)
	sdialecttagpkg := sdialectpkg + "/tag"

	sdialectTag := jen.Qual(sdialecttagpkg, sname+"Tag")
	ssecondaryTag := jen.Qual(sdialecttagpkg, "SelectTag")

	lpkg, err := genutil.PkgInfoFromPath(
		ismDir, packages.NeedName|packages.NeedSyntax|packages.NeedTypes,
	)
	if err != nil {
		return fmt.Errorf("couldn't load source package: %s", err)
	}

	customNamedType := func(st jen.Statement, tt *types.Named) *jen.Statement {
		if tt.Obj().Name() == "QueryMod" && tt.Obj().Pkg().Path() == sqpkg {
			// sq.QueryMod => psql.SelectMod
			return st.Add(jen.Qual(sdialectpkg, sname+"Mod"))
		} else if tt.Obj().Name() == "QueryModApply" && tt.Obj().Pkg().Path() == sqpkg {
			// sq.QueryModApply => psql.SelectModApply
			return st.Add(jen.Qual(sdialectpkg, sname+"ModApply"))
		} else if tt.Obj().Name() == "Query" && tt.Obj().Pkg().Path() == isqpkg {
			// isq.Query => psql.SelectQuery
			// return st.Add(jen.Qual(sdialectpkg, sname+"Query"))
			return st.Add(jen.Qual(sdialectpkg, "SelectQuery"))
		} else if tt.Obj().Pkg().Name() == "chain" && tt.Obj().Pkg().Path() == sqchainpkg {
			// sq/chain.From => FromChain
			return st.Add(jen.Id(fmt.Sprintf("%sChain", tt.Obj().Name())))
		} else if tt.Obj().Pkg().Path() == sqmodpkg {
			// sq/mod/InsertConflictUpdateMod => InsertConflictUpdateMod
			return st.Add(jen.Id(tt.Obj().Name()))
		}
		return nil
	}

	applyFuncConfig := func(name string, fconfig *ConfigDialectModFunc) string {
		if fconfig != nil {
			if fconfig.ReplacePrefix != "" {
				n, _ := strings.CutPrefix(name, fconfig.Prefix)
				name = fconfig.ReplacePrefix + n
			}
		}
		return name
	}

	chains := map[string]int{}

	f := jen.NewFile(sdir)
	f.PackageComment("// Code generated by \"litsql-dialectgen\"; DO NOT EDIT.")

	if lpkg.Types != nil {
		// qual := types.RelativeTo(lpkg.Types)
		scope := lpkg.Types.Scope()
		for _, name := range scope.Names() {
			obj := scope.Lookup(name)
			if !obj.Exported() {
				continue // skip unexported names
			}
			funcTyp, ok := obj.(*types.Func)
			if !ok {
				continue
			}

			// skip functions
			if slices.ContainsFunc(config.FindDialectSkip(*dialect, sdir, []string{
				"RawQuery",
			}), func(s string) bool {
				return strings.HasPrefix(funcTyp.Name(), s)
			}) {
				continue
			}

			docFound := false
			var doc *ast.CommentGroup

			for _, fileAst := range lpkg.Syntax {
				ast.Inspect(fileAst, func(n ast.Node) bool {
					if docFound {
						return false
					}
					if aFunc, ok := n.(*ast.FuncDecl); ok {
						if aFunc.Name.Name == funcTyp.Name() {
							docFound = true
							doc = aFunc.Doc
						}
					}
					return !docFound
				})
				if docFound {
					break
				}
			}

			sig := funcTyp.Type().(*types.Signature)
			// fmt.Printf("%s\n", types.ObjectString(funcTyp, qual))

			if sig.Results().Len() != 1 {
				return fmt.Errorf("function '%s' must have only 1 return value", name)
			}

			// don't generate root Query call
			isChainRet := false
			sigResult := sig.Results().At(0)
			sigResultType, stNamed := sigResult.Type().(*types.Named)
			if stNamed {
				// fmt.Println(sigResultType.Obj().Name(), sigResultType.Obj().Pkg().Path())
				if sigResultType.Obj().Name() == "Query" && sigResultType.Obj().Pkg().Path() == sqpkg {
					continue
				}

				// detect chain return
				if sigResultType.Obj().Pkg().Name() == "chain" && sigResultType.Obj().Pkg().Path() == sqchainpkg {
					isChainRet = true
					chains[sigResultType.Obj().Name()] = sigResultType.TypeParams().Len()
				}
			}

			funcConfig := config.FindDialectFunc(*dialect, sdir, funcTyp.Name())

			funcName := applyFuncConfig(funcTyp.Name(), funcConfig)

			// f.Comment(types.ObjectString(funcTyp, qual))
			if doc != nil {
				for _, docLine := range doc.List {
					f.Comment(docLine.Text)
				}
			}
			f.Func().Id(funcName).
				ParamsFunc(genutil.AddParams(sig.Params(), sig.Variadic(), customNamedType)).
				ParamsFunc(genutil.AddParams(sig.Results(), false, customNamedType)).
				Block(
					jen.ReturnFunc(func(rgroup *jen.Group) {
						rblock := jen.Qual(ispkg, funcTyp.Name()).
							TypesFunc(func(tgroup *jen.Group) {
								for k := 0; k < sig.TypeParams().Len(); k++ {
									if k > 0 {
										if funcConfig != nil && funcConfig.SecondTypeParam != "" {
											tgroup.Add(jen.Qual(sdialecttagpkg, funcConfig.SecondTypeParam))
										} else {
											tgroup.Add(ssecondaryTag)
										}
									} else {
										tgroup.Add(sdialectTag)
									}
								}
							}).
							CallFunc(func(pgroup *jen.Group) {
								for k := 0; k < sig.Params().Len(); k++ {
									sigParam := sig.Params().At(k)
									c := jen.Id(genutil.ParamName(k, sigParam))
									if sig.Variadic() && k == sig.Params().Len()-1 {
										c.Op("...")
									}
									pgroup.Add(c)
								}
							})

						if isChainRet {
							if dchain := config.FindDialectChain(*dialect, sdir, sigResultType.Obj().Name()); dchain != nil {
								rgroup.Op("&").Id(genutil.InitialToLower(sigResultType.Obj().Name()) + "ChainAdapter").
									Block(jen.Id("chain").Op(":").Add(rblock).Op(","))
								return
							}
						}
						rgroup.Add(rblock)
					}),
				)

			f.Line()
		}
	}

	fnfile := filepath.Join(smDir, "fn.go")
	if !*dryRun {
		// fmt.Println(fnfile)
		fnFile, err := os.Create(fnfile)
		if err != nil {
			return err
		}
		defer fnFile.Close()
		err = f.Render(fnFile)
	} else {
		fmt.Println(strings.Repeat("=", 10), fnfile, strings.Repeat("=", 10))
		err = f.Render(os.Stdout)
	}
	if err != nil {
		return err
	}

	if len(chains) > 0 {
		chainNames := maps.Keys(chains)
		slices.Sort(chainNames)

		fchain := jen.NewFile(sdir)
		fchain.PackageComment("// Code generated by \"litsql-dialectgen\"; DO NOT EDIT.")

		fadapters := jen.NewFile(sdir)
		hasAdapters := false

		for _, chain := range chainNames {
			// check for custom chain
			if dchain := config.FindDialectChain(*dialect, sdir, chain); dchain != nil {
				chainObj := chainPkg.Types.Scope().Lookup(chain)
				if chainObj == nil {
					return fmt.Errorf("chain '%s' not found", chain)
				}
				if !chainObj.Exported() {
					continue // skip unexported names
				}
				if !types.IsInterface(chainObj.Type()) {
					return fmt.Errorf("chain '%s' is not an interface", chain)
				}

				chainTyp := chainObj.Type().Underlying().(*types.Interface).Complete()

				hasAdapters = true

				fchain.Type().
					Id(chain + "Chain").
					InterfaceFunc(func(igroup *jen.Group) {
						igroup.Add(jen.Qual(sqpkg, "QueryMod").Types(sdialectTag))
						for cm := range chainTyp.NumMethods() {
							cmethod := chainTyp.Method(cm)
							if !slices.Contains(dchain.Methods, cmethod.Name()) {
								continue
							}
							csig := cmethod.Type().(*types.Signature)

							igroup.Add(jen.Id(cmethod.Name()).
								ParamsFunc(genutil.AddParams(csig.Params(), csig.Variadic(), customNamedType)).
								ParamsFunc(genutil.AddParams(csig.Results(), false, customNamedType)),
							)
						}
					})

				aname := genutil.InitialToLower(chain) + "ChainAdapter"
				fadapters.Type().
					Id(aname).
					Struct(
						jen.Add(jen.Qual(sqpkg, "ModTagImpl").Types(sdialectTag)),
						jen.Add(jen.Id("chain").Qual(sqchainpkg, "From").Types(sdialectTag)),
					)
				fadapters.Line()

				fadapters.Func().
					Params(jen.Id("a").Op("*").Id(aname)).
					Id("Apply").Params(jen.Id("apply").Qual(rootpkg, "QueryBuilder")).
					Block(
						jen.Id("a").Dot("chain").Dot("Apply").Call(jen.Id("apply")),
					)
				fadapters.Line()

				for cm := range chainTyp.NumMethods() {
					cmethod := chainTyp.Method(cm)
					if !slices.ContainsFunc(dchain.Methods, func(s string) bool {
						return strings.HasPrefix(s, cmethod.Name())
					}) {
						continue
					}
					csig := cmethod.Type().(*types.Signature)

					fadapters.Func().
						Params(jen.Id("a").Op("*").Id(aname)).
						Id(cmethod.Name()).
						ParamsFunc(genutil.AddParams(csig.Params(), csig.Variadic(), customNamedType)).
						ParamsFunc(genutil.AddParams(csig.Results(), false, customNamedType)).
						Block(
							jen.Id("_").Op("=").Id("a").Dot("chain").Dot(cmethod.Name()).
								CallFunc(func(pgroup *jen.Group) {
									for k := 0; k < csig.Params().Len(); k++ {
										sigParam := csig.Params().At(k)
										c := jen.Id(genutil.ParamName(k, sigParam))
										if csig.Variadic() && k == csig.Params().Len()-1 {
											c.Op("...")
										}
										pgroup.Add(c)
									}
								}),
							jen.Return(jen.Id("a")),
						)
					fadapters.Line()
				}
			} else {
				fchain.Type().
					Id(chain+"Chain").
					Op("=").
					Qual(sqchainpkg, chain).
					TypesFunc(func(group *jen.Group) {
						group.Add(sdialectTag)
						if chains[chain] > 1 {
							group.Qual(imodpkg, chain+"ModTag")
						}
					})
			}
			fchain.Line()
		}

		chainfile := filepath.Join(smDir, "chain.go")
		if !*dryRun {
			// fmt.Println(fnfile)
			chainFile, err := os.Create(chainfile)
			if err != nil {
				return err
			}
			defer chainFile.Close()
			err = fchain.Render(chainFile)
		} else {
			fmt.Println(strings.Repeat("=", 10), chainfile, strings.Repeat("=", 10))
			err = fchain.Render(os.Stdout)
		}
		if err != nil {
			return err
		}

		if hasAdapters {
			adaptersfile := filepath.Join(smDir, "adapter.go")
			if !*dryRun {
				// fmt.Println(fnfile)
				adaptersFile, err := os.Create(adaptersfile)
				if err != nil {
					return err
				}
				defer adaptersFile.Close()
				err = fadapters.Render(adaptersFile)
			} else {
				fmt.Println(strings.Repeat("=", 10), adaptersfile, strings.Repeat("=", 10))
				err = fadapters.Render(os.Stdout)
			}
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func getCurrentDir() string {
	_, filename, _, ok := runtime.Caller(1)
	if !ok {
		panic("could not determine current directory")
	}
	return filepath.Dir(filename)
}
